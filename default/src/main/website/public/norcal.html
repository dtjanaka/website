<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>N O R C A L ðŸŸªðŸŸ©ðŸŸ©ðŸŸ§</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script src="js/three.js"></script>
    <script src="js/GLTFLoader.js"></script>
    <script src="js/DRACOLoader.js"></script>

    <script>
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8f8ff);

      const camera = new THREE.PerspectiveCamera(
        90,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      });

      camera.position.x = 7;
      camera.position.y = 0;
      camera.position.z = 7;

      camera.up.set(0, 0, 1);
      camera.lookAt(10, 0, 0);

      const light = new THREE.PointLight(0xffffff, 1.2, 0, 2);
      light.position.set(0, 0, 30);
      scene.add(light);

      const ROW_MAX = 6;
      const COL_MAX = 6;

      // cubes are 5.5", tiles are 24.375"
      const TILE_SCALE = 0.01;
      const TILE_SPACING = 2.99279;
      const TILE_Z = 0.08;

      const CUBE_SCALE = 0.01;
      const CUBE_SPACING = 0.6981;
      const CUBE_OFFSET = 0.0952;
      const CUBE_Z = CUBE_SPACING + 2 * TILE_Z;

      const TILE_COLORS = [
        0x626262,
        0x646464,
        0x666666,
        0x686868,
      ];

      // prettier-ignore
      const TILE_COLOR_INDEX = [
        0,3,0,3,0,3,
        3,0,3,0,3,0,
        0,3,0,3,0,3,
        3,0,3,0,3,0,
        0,3,0,3,0,3,
        3,0,3,0,3,0,
      ];

      const group = new THREE.Group();

      const loader = new THREE.GLTFLoader();

      const dracoLoader = new THREE.DRACOLoader();
      dracoLoader.setDecoderPath('/js/draco/');
      loader.setDRACOLoader( dracoLoader );

      loader.load(
        '/gltf/vex/field_tileDraco.gltf',
        function (gltf) {
          gltf.scene.scale.set(TILE_SCALE, TILE_SCALE, TILE_SCALE);
          for (let row = 0; row < ROW_MAX; row++) {
            for (let col = 0; col < COL_MAX; col++) {
              let newScene = gltf.scene.clone();
              newScene.position.set(
                2 * row * TILE_SPACING - (ROW_MAX - 1) * TILE_SPACING,
                2 * col * TILE_SPACING - (COL_MAX - 1) * TILE_SPACING,
                TILE_Z
              );

              let newMaterial = new THREE.MeshLambertMaterial({
                color:
                  TILE_COLORS[TILE_COLOR_INDEX[6 * row + col]],
                depthFunc: THREE.LessDepth, // fix render artifacts at certain angles
              });
              newScene.traverse((o) => {
                if (o.isMesh) o.material = newMaterial;
              });
              group.add(newScene);
            }
          }
        },
        undefined,
        function (error) {
          console.error(error);
        }
      );

      const WALL_XY = 17.85494;
      const WALL_Z_BOTTOM_OFFSET = 0.0277;
      const WALL_Z = 2 * TILE_Z + WALL_Z_BOTTOM_OFFSET;
      const WALL_SCALE = 1;

      const WALL_POSITIONS = [
        [WALL_XY, WALL_XY, Math.PI / 2],
        [WALL_XY, -WALL_XY, 0],
        [-WALL_XY, WALL_XY, Math.PI],
        [-WALL_XY, -WALL_XY, -Math.PI / 2],
      ];

      loader.load(
        '/gltf/vex/field_wallDraco.gltf',
        function (gltf) {
          gltf.scene.scale.set(WALL_SCALE, WALL_SCALE, WALL_SCALE);
          for (let i = 0; i < WALL_POSITIONS.length; i++) {
            let newScene = gltf.scene.clone();
            newScene.position.set(WALL_POSITIONS[i][0], WALL_POSITIONS[i][1], WALL_Z);
            newScene.rotation.z = WALL_POSITIONS[i][2];

            group.add(newScene);
          }
        },
        undefined,
        function (error) {
          console.error(error);
        }
      );

      // prettier-ignore
      const CUBES_NO_OFFSET = [
        [
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), 3 * CUBE_SPACING - CUBE_OFFSET / 2],
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), -3 * CUBE_SPACING + CUBE_OFFSET / 2],
          [3 * TILE_SPACING, 3 * CUBE_SPACING - CUBE_OFFSET / 2],
          [3 * TILE_SPACING + 2 * CUBE_SPACING - CUBE_OFFSET / 2, CUBE_SPACING - CUBE_OFFSET / 2],
          [3 * TILE_SPACING + CUBE_OFFSET / 2, -CUBE_SPACING + CUBE_OFFSET / 2],
          [3 * TILE_SPACING, -3 * CUBE_SPACING + CUBE_OFFSET / 2],
          [3 * TILE_SPACING + 2 * CUBE_SPACING, 3 * CUBE_SPACING - CUBE_OFFSET / 2],
          [3 * TILE_SPACING + 2 * CUBE_SPACING, -3 * CUBE_SPACING + CUBE_OFFSET / 2],
          [3 * TILE_SPACING + 4 * CUBE_SPACING, 3 * CUBE_SPACING - CUBE_OFFSET / 2],
          [3 * TILE_SPACING + 4 * CUBE_SPACING, -3 * CUBE_SPACING + CUBE_OFFSET / 2],
        ],
        [],
        [
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), 2 * CUBE_SPACING],
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), -2 * CUBE_SPACING + 2 * CUBE_OFFSET],
          [3 * TILE_SPACING, 2 * CUBE_SPACING],
          [3 * TILE_SPACING, 0],
          [3 * TILE_SPACING + 2 * CUBE_SPACING, 2 * CUBE_SPACING],
          [3 * TILE_SPACING + 2 * CUBE_SPACING, -2 * CUBE_SPACING + 2 * CUBE_OFFSET],
          [3 * TILE_SPACING + 4 * CUBE_SPACING, CUBE_SPACING + CUBE_OFFSET],
          [3 * TILE_SPACING + 4 * CUBE_SPACING, -CUBE_SPACING + CUBE_OFFSET],
        ],
        [
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), CUBE_SPACING],
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), -CUBE_SPACING],
          [2 * TILE_SPACING + (TILE_SPACING - CUBE_SPACING), 3 * CUBE_SPACING],
          [2 * TILE_SPACING + (TILE_SPACING - CUBE_SPACING), -3 * CUBE_SPACING],
          [3 * TILE_SPACING + CUBE_SPACING, 3 * CUBE_SPACING],
          [3 * TILE_SPACING + 3 * CUBE_SPACING, 3 * CUBE_SPACING],
          [3 * TILE_SPACING + 3 * CUBE_SPACING, -3 * CUBE_SPACING],
          [3 * TILE_SPACING + 4 * CUBE_SPACING, CUBE_SPACING],
          [3 * TILE_SPACING + 4 * CUBE_SPACING, -CUBE_SPACING],
        ],
        [],
        [
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), 2 * CUBE_SPACING],
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), 0],
          [2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), -2 * CUBE_SPACING],
          [3 * TILE_SPACING, 2 * CUBE_SPACING],
          [3 * TILE_SPACING + 2 * CUBE_SPACING, 2 * CUBE_SPACING],
          [3 * TILE_SPACING + 4 * CUBE_SPACING, 2 * CUBE_SPACING],
        ]
      ];

      const CUBE_ROTATIONS = [
        -Math.PI / 6,
        0,
        (-5 * Math.PI) / 6,
        (5 * Math.PI) / 6,
        0,
        Math.PI / 6,
      ];

      function trX(x, y, rad) {
        return x * Math.cos(rad) - y * Math.sin(rad);
      }

      function trY(x, y, rad) {
        return x * Math.sin(rad) + y * Math.cos(rad);
      }

      // prettier-ignore
      let CUBE_POSITIONS = [
        [], // N
        [
          // O
          new THREE.Vector3(CUBE_SPACING, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)), CUBE_Z),
          new THREE.Vector3(-CUBE_SPACING, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)), CUBE_Z),
          new THREE.Vector3(CUBE_SPACING, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)) - 6 * CUBE_SPACING + 2 * CUBE_OFFSET, CUBE_Z),
          new THREE.Vector3(-CUBE_SPACING, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)) - 6 * CUBE_SPACING + 2 * CUBE_OFFSET, CUBE_Z),
          new THREE.Vector3(3 * CUBE_SPACING - CUBE_OFFSET, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)) - 2 * CUBE_SPACING + CUBE_OFFSET, CUBE_Z),
          new THREE.Vector3(3 * CUBE_SPACING - CUBE_OFFSET, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)) - 4 * CUBE_SPACING + CUBE_OFFSET, CUBE_Z),
          new THREE.Vector3(-3 * CUBE_SPACING + CUBE_OFFSET, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)) - 2 * CUBE_SPACING + CUBE_OFFSET, CUBE_Z),
          new THREE.Vector3(-3 * CUBE_SPACING + CUBE_OFFSET, -(2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING)) - 4 * CUBE_SPACING + CUBE_OFFSET, CUBE_Z),
        ],
        [], // R
        [], // C
        [
          // A
          new THREE.Vector3(3 * CUBE_SPACING, 2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), CUBE_Z),
          new THREE.Vector3(-3 * CUBE_SPACING, 2 * TILE_SPACING + (TILE_SPACING - 2 * CUBE_SPACING), CUBE_Z),
          new THREE.Vector3(3 * CUBE_SPACING, 3 * TILE_SPACING, CUBE_Z),
          new THREE.Vector3(CUBE_SPACING, 3 * TILE_SPACING, CUBE_Z),
          new THREE.Vector3(-CUBE_SPACING, 3 * TILE_SPACING, CUBE_Z),
          new THREE.Vector3(-3 * CUBE_SPACING, 3 * TILE_SPACING, CUBE_Z),
          new THREE.Vector3(3 * CUBE_SPACING, 3 * TILE_SPACING + 2 * CUBE_SPACING, CUBE_Z),
          new THREE.Vector3(-3 * CUBE_SPACING, 3 * TILE_SPACING + 2 * CUBE_SPACING, CUBE_Z),
          new THREE.Vector3(CUBE_SPACING, 3 * TILE_SPACING + 4 * CUBE_SPACING - 2 * CUBE_OFFSET, CUBE_Z),
          new THREE.Vector3(-CUBE_SPACING, 3 * TILE_SPACING + 4 * CUBE_SPACING - 2 * CUBE_OFFSET, CUBE_Z),
        ],
        [], // L
      ];

      const N = 0;
      const O = 1;
      const R = 2;
      const C = 3;
      const A = 4;
      const L = 5;

      for (let letter = N; letter <= L; letter++) {
        if (letter === O || letter === A) {
          continue;
        }
        for (let cube = 0; cube < CUBES_NO_OFFSET[letter].length; cube++) {
          CUBE_POSITIONS[letter].push(
            new THREE.Vector3(
              trX(
                CUBES_NO_OFFSET[letter][cube][0],
                CUBES_NO_OFFSET[letter][cube][1],
                CUBE_ROTATIONS[letter]
              ),
              trY(
                CUBES_NO_OFFSET[letter][cube][0],
                CUBES_NO_OFFSET[letter][cube][1],
                CUBE_ROTATIONS[letter]
              ),
              CUBE_Z
            )
          );
        }
      }

      const PURPLE = 0x6a429b;
      const GREEN = 0x21ae4e;
      const ORANGE = 0xf67429;
      const CUBE_COLORS = [ORANGE, PURPLE, GREEN, ORANGE, PURPLE, GREEN];

      loader.load(
        '/gltf/vex/tt/tower_takeover_cubeDraco.gltf',
        function (gltf) {
          gltf.scene.scale.set(CUBE_SCALE, CUBE_SCALE, CUBE_SCALE);
          for (let letter = N; letter <= L; letter++) {
            for (let i = 0; i < CUBE_POSITIONS[letter].length; i++) {
              let newScene = gltf.scene.clone();
              newScene.position.copy(CUBE_POSITIONS[letter][i]);
              newScene.rotation.set(0, 0, CUBE_ROTATIONS[letter]);

              let newMaterial = new THREE.MeshLambertMaterial({
                color: CUBE_COLORS[letter],
              });
              newScene.traverse((o) => {
                if (o.isMesh) o.material = newMaterial;
              });
              group.add(newScene);
            }
          }
        },
        undefined,
        function (error) {
          console.error(error);
        }
      );

      scene.add(group);

      function animate() {
        requestAnimationFrame(animate);

        group.rotation.z += (1 / 15) * (1 / 60) * 2 * Math.PI;

        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>